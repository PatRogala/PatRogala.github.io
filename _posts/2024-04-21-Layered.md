---
title: Database Queries
date: 2024-04-21 15:33:55 +0000
categories: [Ruby on Rails, Layered Design for Ruby on Rails Applications]
tags: [ruby, rails, web, layered design]
---

## Streamlining Database Queries in Rails with Active Record

Active Record lets you query databases without SQL. You use a method called method chaining, which reads like plain English. For example, to load published posts in order by date, you write:

```ruby
Post.where(draft: false).order(created_at: :desc)
```

This gives you a simple SQL command to get posts from newest to oldest.

In Rails, you can also handle complex queries with Active Record. For instance, to find users with bookmarked posts from last week

```ruby
User.with(
 bookmarked_posts: Post.where(created_at: Date.current.prev_week.all_week)
 .where.associated(:bookmarks).select(:user_id).distinct
).joins(:bookmarked_posts)
```

Placing these queries directly in controllers or jobs affects how easy it is to maintain the code. Changes in business logic or updates (like adding soft deletion for posts) require updating the queries:

```ruby
Post.where(deleted_at: nil).where(draft: false).order(created_at: :desc)
```

This increases the risk of bugs if updates are missed. Also, testing these queries requires more complex tests, slowing down productivity.

To improve maintainability, Rails encourages moving complex queries to model class methods or named scopes, which reduce duplication and make code easier to manage:

```ruby
class Post < ApplicationRecord
 scope :ordered, -> { order(created_at: :desc) }
 scope :published, -> { where(draft: false) }
 scope :kept, -> { where(deleted_at: nil) }
 scope :previous_week, -> {
 where(created_at: Date.current.prev_week.all_week)
 }
end

Post.kept.published.ordered
```

This makes the model a central place for queries but increases the need for updates due to its many roles.

## Why and when extract Query Logic into Separate Objects

It's a great idea to extract the User.with_bookmarked_posts method into a separate query object for several reasons:

1. **Decoupling from Model**: The method is self-contained and doesn't rely directly on the model's internal details, which makes it an ideal candidate for extraction. This reduces the complexity within the model itself and adheres to the Single Responsibility Principle by allowing the model to focus primarily on its inherent attributes and behaviors.
2. **Limited Use Context**: Since the logic encapsulated by this method is specific to certain parts of the application and not a generic requirement across various components, it's beneficial to segregate it from the general model class. This approach aligns with best practices in software design, which advocate for keeping generic logic within models and segregating context-specific logic into specialized objects or services.

By moving this method into a separate UserWithBookmarkedPostsQuery class, you can achieve better organization and maintainability of your code. This new class encapsulates the query logic, making it easier to manage, test, and modify independently of the rest of your application logic.

Here's how you might structure the new query object class:

```ruby
class UserWithBookmarkedPostsQuery
  def call(period = :previous_week)
    bookmarked_posts = Post.public_send(period)
                            .where.associated(:bookmarks)
                            .select(:user_id).distinct
    User.with(bookmarked_posts:).joins(:bookmarked_posts)
  end
end
```

Usage of this new query object would be straightforward and centralized:

```ruby
UserWithBookmarkedPostsQuery.new.call
```

This refactoring not only simplifies the model but also enhances the modularity and reusability of the query logic, conforming to object-oriented design principles.
