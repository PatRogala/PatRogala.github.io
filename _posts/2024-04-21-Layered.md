---
title: Rails Database Queries
date: 2024-04-21 15:33:55 +0000
categories: [Ruby on Rails, Layered Design for Ruby on Rails Applications]
tags: [ruby, rails, web, layered design, database, queries, arel, active record,]
---

## Streamlining Database Queries in Rails with Active Record

Active Record lets you query databases without SQL. You use a method called method chaining, which reads like plain English. For example, to load published posts in order by date, you write:

```ruby
Post.where(draft: false).order(created_at: :desc)
```

This gives you a simple SQL command to get posts from newest to oldest.

In Rails, you can also handle complex queries with Active Record. For instance, to find users with bookmarked posts from last week

```ruby
User.with(
 bookmarked_posts: Post.where(created_at: Date.current.prev_week.all_week)
 .where.associated(:bookmarks).select(:user_id).distinct
).joins(:bookmarked_posts)
```

Placing these queries directly in controllers or jobs affects how easy it is to maintain the code. Changes in business logic or updates (like adding soft deletion for posts) require updating the queries:

```ruby
Post.where(deleted_at: nil).where(draft: false).order(created_at: :desc)
```

This increases the risk of bugs if updates are missed. Also, testing these queries requires more complex tests, slowing down productivity.

To improve maintainability, Rails encourages moving complex queries to model class methods or named scopes, which reduce duplication and make code easier to manage:

```ruby
class Post < ApplicationRecord
 scope :ordered, -> { order(created_at: :desc) }
 scope :published, -> { where(draft: false) }
 scope :kept, -> { where(deleted_at: nil) }
 scope :previous_week, -> {
  where(created_at: Date.current.prev_week.all_week)
 }
end

Post.kept.published.ordered
```

This makes the model a central place for queries but increases the need for updates due to its many roles.

## Why and when extract Query Logic into Separate Objects

It's a great idea to extract the User.with_bookmarked_posts method into a separate query object for several reasons:

1. **Decoupling from Model**: The method is self-contained and doesn't rely directly on the model's internal details, which makes it an ideal candidate for extraction. This reduces the complexity within the model itself and adheres to the Single Responsibility Principle by allowing the model to focus primarily on its inherent attributes and behaviors.
2. **Limited Use Context**: Since the logic encapsulated by this method is specific to certain parts of the application and not a generic requirement across various components, it's beneficial to segregate it from the general model class. This approach aligns with best practices in software design, which advocate for keeping generic logic within models and segregating context-specific logic into specialized objects or services.

By moving this method into a separate UserWithBookmarkedPostsQuery class, you can achieve better organization and maintainability of your code. This new class encapsulates the query logic, making it easier to manage, test, and modify independently of the rest of your application logic.

Here's how you might structure the new query object class:

```ruby
class UserWithBookmarkedPostsQuery
  def call(period = :previous_week)
    bookmarked_posts = Post.public_send(period)
                            .where.associated(:bookmarks)
                            .select(:user_id).distinct
    User.with(bookmarked_posts:).joins(:bookmarked_posts)
  end
end
```

Usage of this new query object would be straightforward and centralized:

```ruby
UserWithBookmarkedPostsQuery.new.call
```

This refactoring not only simplifies the model but also enhances the modularity and reusability of the query logic, conforming to object-oriented design principles.

## Reusable Query Objects

Using reusable query objects and the power of Arel can streamline your application's database interactions significantly, especially when dealing with complex or model-wide querying needs.

###  A Practical Application

Letâ€™s assume we've enhanced the Post model by adding a feature for tagging posts stored as a JSON array in the database. Similarly, we've extended this tagging functionality to the Bookmark model. Given the identical querying needs of both models (retrieving items based on tags), it becomes efficient to extract this common functionality into a reusable query object, reducing redundancy and improving maintainability.

### Example: TaggedQuery Class

We created a TaggedQuery class that can be applied to any model, thus encapsulating the tag-related query logic:

```ruby
class TaggedQuery < ApplicationQuery
  def resolve(tag)
    relation.where("EXISTS (SELECT 1 FROM json_each(tags) WHERE value = ?)", tag)
  end
end
```

This query object is not directly attached to any model but can be invoked like so:

```ruby
# For posts
TaggedQuery.new(Post.all).resolve("rails")
# For bookmarks
TaggedQuery.new(user.bookmarks).resolve("ruby")
```

### Arel Integration: Enhancing Query Flexibility

When SQL queries become complex, raw string manipulation becomes risky and hard to manage. This is where Arel, a part of the Active Record library, becomes invaluable. Arel abstracts SQL into a relational algebra that is safer and more robust to use.

For example, our TaggedQuery class can be rewritten using Arel to handle tags more efficiently and securely:

```ruby
class TaggedQuery < ApplicationQuery
  def resolve(tag)
    subquery = tags.project(1).where(tags[:value].eq(tag))
    relation.where(subquery.exists)
  end

  private

  def tags
    @tags ||= Arel::Nodes::NamedFunction.new("json_each", [arel_table[:tags]]).then do
      name = Arel.sql(_1.to_sql)
      Arel::Table.new(name, as: :json_tags)
    end
  end

  def arel_table = self.class.query_model.arel_table
end
```

This approach provides greater composability and flexibility, leveraging Ruby's object-oriented capabilities.

### Organizing Query Objects

Where should these query objects reside? Ideally, they should be kept in a dedicated directory within the application, separate from the models. This separation not only helps in organizing the code better but also isolates advanced database interaction logic from the more straightforward model definitions, thus adhering to the Single Responsibility Principle.
